/*
 * Copyright (C) 2002-2007 Novamente LLC
 * Copyright (C) 2008-2009 by Singularity Institute for Artificial Intelligence
 * All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include "opencog/reasoning/pln/PLN.h"
#include "opencog/reasoning/pln/rules/Rules.h"

#define BackInferenceTreeRootT BITNodeRoot

#include "opencog/reasoning/pln/AtomSpaceWrapper.h"
#include "opencog/reasoning/pln/BackInferenceTreeNode.h"
#include "opencog/reasoning/pln/ForwardChainer.h"

#include "opencog/reasoning/pln/rules/RuleApp.h"

#include <stdlib.h>
#include <time.h>
#ifndef WIN32
    #include <sys/time.h>
#endif

#include "opencog/reasoning/pln/rules/RuleProvider.h"

#include <opencog/util/Config.h>
#include <opencog/util/exceptions.h>
#include <opencog/guile/SchemeEval.h>
#include <opencog/server/load-file.h>

using namespace opencog::pln;
using namespace opencog;
using namespace std;

#include <boost/filesystem.hpp>

using namespace boost::filesystem;

#define RUN_FAILURE_TESTS 0
#define WAIT_KEY_ON_FAILURE 0

// We must use the OPENCOG_SOURCE_DIR var supplied by the CMake script to
// ensure we find the files whether or not we're building using a separate build
// dir
#define PLN_TEST_DIR OPENCOG_SOURCE_DIR"/tests/reasoning/pln/"

#if 0
#include <windows.h>
#include <Mmsystem.h>

#if defined(_MSC_VER) || defined(__MINGW32__)
#  include <time.h>
#ifndef _TIMEVAL_DEFINED /* also in winsock[2].h */
#define _TIMEVAL_DEFINED
struct timeval {
    long tv_sec;
    long tv_usec;
};
#endif /* _TIMEVAL_DEFINED */
#else
#  include <sys/time.h>
#endif

#if defined(_MSC_VER) || defined(__MINGW32__)
int gettimeofday(struct timeval* tp, void* tzp) {
    unsigned long t;
    t = timeGetTime();
    tp->tv_sec = t / 1000;
    tp->tv_usec = t % 1000;
    /* 0 indicates that the call succeeded. */
    return 0;
}
#endif
#endif

const strength_t EPSILON_S = 0.001;
const confidence_t EPSILON_C = 0.001;

namespace test
{
    extern FILE *logfile;
    extern double custom_duration;
    extern double custom_duration2;
}

FitnessEvaluatorT testFitnessEvaluator;
void initAxiomSet(string premiseFile);

// These are now in PLNUtils.h
//#define NewNode(_T, _NAME) mva(nm->addNode(_T, _NAME, TruthValue::TRIVIAL_TV(), false,false))
//#define makemeta(atom_description) meta(new tree<Vertex>(atom_description))

#define maketest(test_description,a,b,c,d) \
    runPLNTest(Btr<PLNTest>(new PLNTest(test_description,a,b,c,d)))

float getCount(float c)
{ return SimpleTruthValue::confidenceToCount(c); }

namespace opencog {
namespace pln {
    extern unsigned long now_interval_len   ;
}}

vector< vector<vector<int> > >  INstatsVT;
vector<vector<int> > INstatsV;
vector<int> INstats;
static int allTestsInferenceNodes=0;

// Make the debug level high during infer steps (only)
//bool foo42=false;

/**
 * The tests load in various xml axiom sets and run until the target with a
 * specific confidence minimum has been reached (or max. nr of steps have been
 * exceeded, resulting in failure.)
 */        
struct PLNTest
{
    meta target;
    TruthValue* minTV, *maxTV;

    uint minEvalsOfFittestBIT; //Divided by ten
    uint minExhaustiveEvals; //Use either this one or the prev one
    PLNTest(meta _target,
            TruthValue* _minTV,
            TruthValue* _maxTV,
            uint _minEvalsOfFittestBIT,
            uint _minExhaustiveEvals)
        : target(_target), minTV(_minTV), maxTV(_maxTV),
          minEvalsOfFittestBIT(_minEvalsOfFittestBIT),
          minExhaustiveEvals(_minExhaustiveEvals)
    {}
};

void runPLNTest(Btr<PLNTest> t);

const float temperatures[] = {
    0.00005, 0.00007, 10,
    0.0001, 0.0003, 0.0005,
    0.001, 0.003, 0.005,
    0.01, 0.03, 0.05,
    0.1, 0.3, 0.5,
    1, 3, 5 };

class PLNUTest :  public CxxTest::TestSuite {

private:
    AtomSpaceWrapper *atw;
    FILE *f;

    // stuff for running tests multiple times,
    // for non-deterministic heuristic functions
    static const int TestRepeats = 1;
    int seed;
    int tempi;
    // test repeat #
    int t;
    
    float temperature;
    static const int temperaturesN = 7; //3*5;
    
    // Setting this false makes the Scheme targets get tested using forward chaining.
    // This is set false during testSCMTargetsFC.
    bool TESTING_BACKWARD_CHAINING;

    // Only runs some tests relevant to testing heuristic functions
    void runPLNTestsOnce() {
        // if you want to disable some of these tests,
        // comment out the content in their implementation
        // (so that they won't be run outside of testHeuristic either)
        testSCMTargets();
        testTVChecksWork();
        testRandomTVsTooHigh();
        testSymmetricRelationFails();
//        testInverseBinding();
        testBasicSpawning();
/*        testMultipleRootsSpawning();
        testGeneralizationForVariableScopeLink();
        testGeneralizationForForAllLink();
        testInheritanceOsamaAbu();
        testInheritanceMuhummadTerrorist();
        testAnotBdemo();
        testFetchDemo5();
        testFetchDemo5_alt();
        testWoaDemo();*/

        INstatsV.push_back(INstats);
    }
    
    /**
     * If a nondeterministic function is used for fitness evaluator
     * then try running all the tests with different temperatures/seeds.
     */
    void setupHeuristicTestRun() {
        if (testFitnessEvaluator == BEST)
            return;
    
        INstatsV.clear();

        temperature = temperatures[tempi];

        //time_t seconds;
        //time(&seconds);
        int seconds = 1;
        srand((unsigned int) seconds+(seed++));
        allTestsInferenceNodes = 0;
    }

    //! @todo have a setup method in PLNModule that is also used in PLNUTest
    void initPLNTests()
    {
        try
        {
            config().load("pln-test.conf");
        }
        catch (RuntimeException &e)
        {
            std::cerr << e.getMessage() << std::endl;
        }

#if LOG_ON_FILE
        test::logfile=fopen("pln.log","wt");
        cout << "LOGGING TO FILE pln.log!\n";
#endif
        //assert(finger_print_test(*tests[0]) != finger_print_test(*tests[1]));

        // Get config settings from config file.
        // Don't tackily override them here.
        // config().set("PLN_LOG_LEVEL","2");
        // config().set("PLN_PRINT_REAL_ATOMS","true");
        //config().set("PLN_RECORD_TRAILS","true");

        //testFitnessEvaluator = BEST;
        //currentDebugLevel = -4;
        currentDebugLevel = config().get_int("PLN_LOG_LEVEL");
        
        TESTING_BACKWARD_CHAINING = true;
    }

    // Now uses SCM. Won't search any alternative locations for the file.
    void initAxiomSet(string premiseFile)
    {
        AtomSpaceWrapper *atw = GET_ASW;
        atw->reset();
        atw->allowFWVarsInAtomSpace = true;

        //cprintf(-2,"loading...\n");     
        std::cout << "loading " << premiseFile << std::endl;

#if 0
        atw->archiveTheorems = true;
        bool axioms_ok = atw->loadAxioms(premiseFile);
        if (!axioms_ok) throw std::string("failed to load file");
        atw->archiveTheorems = false;

#elif HAVE_GUILE
        int rc = load_scm_file(premiseFile.c_str());

        atw->archiveTheorems = true;
        atw->makeCrispTheorems();
        atw->archiveTheorems = false;

        // The error-checking is after the call to makeCrispTheorems, because
        // if there was an error, then the AS is now empty and makeCrispTheorems
        // will (correctly) record that there are none.
        if (rc) throw std::string("failed to load file");
#else
        throw std::string("Not allowed to use XML or SCM!");
#endif
        
        cprintf(-2,"%s loaded. Next test: ", premiseFile.c_str());
    }

// Does 1000 runs per expansion phase
    void runPLNTest(Btr<PLNTest> t)
    {
        AtomSpaceWrapper *atw = GET_ASW;
        stats::Instance().ITN2atom.clear();

        //currentDebugLevel=0;
        rawPrint(*t->target, t->target->begin(), -2);
        
        clock_t start, finish;
        double duration;

        test::custom_duration = 0.0;
        start = clock();
        
        atw->allowFWVarsInAtomSpace = true;
        
        fflush(stdout);
        //currentDebugLevel=-4;

        Btr<BackInferenceTreeRootT> state;
        ForwardChainer fc;

        if (TESTING_BACKWARD_CHAINING) {
            state.reset(new BITNodeRoot(t->target, new DefaultVariableRuleProvider(), config().get_bool("PLN_RECORD_TRAILS"), testFitnessEvaluator));
        }
        uint s_i=0; // Expansion phase #
        pHandle eh=PHANDLE_UNDEFINED;
        TruthValue* etv = NULL;
        bool passed=false;

        set<VtreeProvider*> eres;

        t->minEvalsOfFittestBIT *= 100; //Minimum "resolution"

        const int expansions_per_run = 1000;

        if (t->minEvalsOfFittestBIT > 0) {
            do {
/*              for (int k=0;k<expansions_per_run;k++)
                    state->expandFittest();
                
                eres = state->evaluate();*/

                cprintf(-3, "\n    Evaluating...\n");
                
                //if (foo42)
                    //currentDebugLevel=4;
                
                int expansions = expansions_per_run;
                if (TESTING_BACKWARD_CHAINING) {
                    eres = state->infer(expansions, 0.000001f, 0.01f);
                } else {
                    eh = fc.fwdChainToTarget(expansions, (t->target));
                    //if (!results.empty()) eh = results[0];
                }
                
                if (expansions > 0)
                    cprintf(-3, "Succeeded. Saved $%d / $%d (from the "
                            "beginning of the cycle).\n", expansions,
                            expansions_per_run);
                else
                    cprintf(2, "Failed for now... Saved $%d / $%d (from the "
                            "beginning of the cycle).\n", expansions,
                            expansions_per_run);

                //currentDebugLevel=-4;

                if (TESTING_BACKWARD_CHAINING) 
                    eh = (eres.empty() ? PHANDLE_UNDEFINED :
                            _v2h(*(*eres.rbegin())->getVtree().begin()));                

                if (eh != PHANDLE_UNDEFINED )
                    etv = atw->getTV(eh).clone();
//                else
//                    etv = new SimpleTruthValue(0.0f,0.0f);

               /* float c1=t->minTV->getConfidence();
                float c2=t->maxTV->getConfidence();
                float m1=t->minTV->getMean();
                float m2=t->maxTV->getMean(); */

                if (etv) {
                    printf("c: %f min: %f\n", etv->getConfidence(),
                            t->minTV->getConfidence());
                    printf("s: %f min: %f\n", etv->getMean(),
                            t->minTV->getMean());
                    printf("c: %f max: %f\n", etv->getConfidence(),
                            t->maxTV->getConfidence());
                    printf("s: %f max: %f\n", etv->getMean(),
                            t->maxTV->getMean());

                    if (TESTING_BACKWARD_CHAINING) { // FC doesn't support trails currently
                        std::cout << "Inference trail: " << std::endl;
                        state->printTrail(eh);
                    }
                }
                
                passed = (
                    eh != PHANDLE_UNDEFINED &&
                    etv &&
                    etv->getConfidence() >= t->minTV->getConfidence() &&
                    etv->getMean()       >= t->minTV->getMean() &&
                    etv->getConfidence() <= t->maxTV->getConfidence() &&
                    etv->getMean()       <= t->maxTV->getMean()
                );
        
                cprintf(-4, "TEST Expansion phase %d over.\n", s_i);
            }
            while ((++s_i)*expansions_per_run < t->minEvalsOfFittestBIT
                    && !passed);
        }
        else if (t->minExhaustiveEvals > 0) {
            assert(0);
            /// This should be updated to reflect the new BITNode interface
            /*
            for (uint L=0;L<t->minExhaustiveEvals;L++)
                state->expandNextLevel();

            eres = state->evaluate();
            eh = (eres.empty() ? NULL : v2h(eres.rbegin()->value));
            if (eh) {
                if (etv != NULL) delete etv;
                etv = atw->TV(eh).clone();
            }

            passed = (eh && etv &&
                etv->getConfidence() > t->minTV->getConfidence() &&
                etv->getMean()          > t->minTV->getMean()
                );*/
        }
        else
            puts("ERROR IN TEST SETTINGS");

        if (passed) {
            printf("\n"
                   "**********************************************\n"
                   "passed: %s.\n"
                   "**********************************************\n",
                (etv?etv->toString().c_str():"(null TV)"));

            finish = clock();
            duration = (double)(finish - start) / CLOCKS_PER_SEC;
            printf( "Test took %2.2f seconds TOTAL.\n", duration );

            printf( "Custom test time was %3.3f seconds.\n",
                    test::custom_duration );
            printf( "Custom test time was %3.3f seconds.\n",
                    test::custom_duration2 );
        }
        else {
            printf("\n**********************************************\n"
                   "FAILED: %s!\n"
                   "**********************************************\n",
            (etv?etv->toString().c_str():"(null TV)"));
        }

        if (TESTING_BACKWARD_CHAINING) {
            printf("Test results: [");
            
            foreach(VtreeProvider* bv, eres) {
                const TruthValue& tv = atw->getTV(vt2h(*bv));
                if (!tv.isNullTv() && tv.getConfidence()>0.0001f)
                    printf("%d ", vt2h(*bv));
            }
            printf("]\n");
    
            if (passed) {
                allTestsInferenceNodes += state->inferenceNodes;
    
                INstats.push_back(state->inferenceNodes);
    
                cout << endl << "Exec pool size: " << state->exec_pool.size();
                cout << endl << "InferenceNodes: " << state->inferenceNodes <<
                        " (" << allTestsInferenceNodes << " in all tests)" << endl;
            }
            else
                INstats.push_back(0);
        }
/*      if (etv) {
            string stv(etv->toString());
            puts(stv.c_str());
        }*/

        //stats::Instance().print(stats::triviality_filterT());

        TS_ASSERT(passed);
#if WAIT_KEY_ON_FAILURE
        if (!passed)
            getc(stdin);
#endif
        if (etv != NULL) delete etv;
        //atw->reset(NULL);
    }

    //! @todo Replace with an existing method, after tweaking various things to
    //! make it suitable.
    static SimpleTruthValue* parseSTV(const char* tvStr) {
        float mean, conf;
        sscanf(tvStr, "[%f,%f]", &mean, &conf);
        return new SimpleTruthValue(mean, getCount(conf));
    }

    // Beware that this will create the target as a hypothetical atom
    // before running the inference. It does give the virtual version
    // to the BIT, however.
    void runSCMTarget(const char* conf_file)
    {
#ifdef HAVE_GUILE
        Config test;
        std::cout << conf_file << std::endl;
        test.load(conf_file);
        //std::cout << test.to_string() << std::endl;
        
        std::cout << test["COMMENT"] << std::endl;

        //std::string axiomsFile = std::string(PLN_TEST_DIR)+test["LOAD"]+".xml";        
        std::string axiomsFile = std::string(PLN_TEST_DIR"scm/")+test["LOAD"]+".scm";
        
        try {
            initAxiomSet(axiomsFile);
        } catch (...) {
            TS_FAIL("Couldn't find file");
            return;
        }
        //// Hack to show atoms in atomspace
        /*std::vector<Handle> all_atoms;
        std::vector<Handle>::iterator it;
        std::back_insert_iterator< std::vector<Handle> > out_hi(all_atoms);
        server().getAtomSpace()->getHandleSet(out_hi, ATOM, true);
        std::ostringstream oss;

        for (it = all_atoms.begin(); it != all_atoms.end(); ++it) {
            Atom* atom = TLB::getAtom(*it);
            oss << atom->toString() << std::endl;
        }
        cout << oss.str();*/
        ////
        
        std::string targetScheme = test["TARGET"];
        if (TESTING_BACKWARD_CHAINING)
            std::cout << "Back-chaining target: " << targetScheme << std::endl;
        else
            std::cout << "Forward-chaining target: " << targetScheme << std::endl;
        
        // get target atom
        SchemeEval& eval = SchemeEval::instance();        
        Handle h = eval.eval_h(targetScheme);

        pHandleSeq fakeHandles =
            ((AtomSpaceWrapper*)ASW())->realToFakeHandle(h);
        pHandle fakeHandle = fakeHandles[0];
        //meta target(new vtree(fakeHandle));
        
        meta target_(new vtree(fakeHandle));
        
        meta target = ForceAllLinksVirtual(target_);
        
        // Set parameters
        uint maxSteps = test.get_int("MAX_STEPS");

        // Make sure FC doesn't take too long / only test it on simpler tests.
        // It takes disproportionately long once the AtomSpace gets large, due
        // to the indexes probably. 
        if (!TESTING_BACKWARD_CHAINING && maxSteps > 201) {
            std::cout << "Skipping test due to time constraints" << std::endl;
            return; //minEvalsOfFittestBIT = 500;
        }
        
        uint minEvalsOfFittestBIT = maxSteps/100;
        
        // Changed because we don't want to have to specify the count
        // as well, in the test's .conf file
        //TruthValue* minTV = SimpleTruthValue::fromString(test["MIN_TV"].c_str());
        //TruthValue* maxTV = SimpleTruthValue::fromString(test["MAX_TV"].c_str());
        TruthValue* minTV = parseSTV(test["MIN_TV"].c_str());
        TruthValue* maxTV = parseSTV(test["MAX_TV"].c_str());

        std::cout << "Loaded parameters of test OK" << std::endl;

        // Run the test using runPLNTest (via the maketest macro)
        maketest(target,
                 minTV,
                 maxTV,
                 minEvalsOfFittestBIT,
                 0); // Alternative (not used) method for limiting test time
#endif // HAVE_GUILE
    }


public:

    static PLNUTest* createSuite() { return new PLNUTest(); }
    static void destroySuite(PLNUTest* suite) { delete suite; }

    PLNUTest()
    {
        // initial values for running tests multiple times
        seed = 11111;
        tempi=0;
        // test repeat #
        t = 0;
        temperature = 0.1f;
    
        // Initialize PLN test environment
        try {        
            logger().info("Initializing PLN test env...");

            f = fopen("results.txt","a");

            //currentDebugLevel=100;

            atw = GET_ASW;                                  
        }
        catch(std::string s) {
            logger().error("at root level while initializing.");
        }
        catch(PLNexception e)
        {
            logger().error("at root level while initializing.");
        }
        catch(...)
        {
            logger().error("Unknown exception at root level while initializing. ");
        }
        
        // Initialize PLN tests as such
        initPLNTests();

#ifdef HAVE_GUILE
        // Necessary if you use test data and/or targets in Scheme.
        logger().debug("Loading Scheme modules");
        config().set("SCM_PRELOAD",
                "opencog/scm/type_constructors.scm,"
                "opencog/scm/utilities.scm");
        // Blindly search a bunch of paths hoping to find the files
        // in one of them ...
        const char * paths[] = 
        {
                "./",
                "../",
                "../../",
                "../../../",
                "../../../..",
                NULL
        };
        cogserver().loadSCMModules(paths);
#endif

        allTestsInferenceNodes = 0;

        INstats.clear();

        if(RUN_FAILURE_TESTS)
            puts("NOTE! 3 first tests are supposed to fail.");
            
    }
    
    ~PLNUTest()
    {
        // t = test repeat #
        // f = results.txt
        // TestRepeats
        
//        uint t = 0;
//        uint TestRepeats = 1;
    
        // some stats stuff
        INstatsV.push_back(INstats);
    
        INstatsV[t].push_back(allTestsInferenceNodes);
        INstatsVT.push_back(INstatsV);

        for (uint v=0; v < INstatsV[0].size(); v++)
        {
            fprintf(f, "\n");
            for (int t=0; t < ( (testFitnessEvaluator!=BEST) ? TestRepeats : 1); t++)
                fprintf(f, "%d ", INstatsV[t][v]);
        }

        fclose(f);
    }
    
/*    static PLNUTest* DISABLEcreateSuite()
    {
        PLNUTest* test = new PLNUTest();
        test->multipleTestRunsForHeuristic();
        return test;
    }
    
    
    static void DISABLEdestroySuite(PLNUTest* suite) { delete suite; }*/
    
    void setUp()
    {
    }
    
    void tearDown()
    {
    }
    
    void testSCMTargets () {
        // TODO maybe use regex_iterator
        
        // This method is the main one for current and future tests.
        // Also, there are a lot of different errors that can happen.
        // So, it has/needs somewhat elaborate exception-handling.
        // This is partly because CXXTest doesn't give you any info
        // about an exception, just telling you it happened.
        try {
            string testDir = PLN_TEST_DIR"targets";

            // TODO apparently there is a way to make iterators only cover
            // either files or directories. The boost::filesystem
            // documentation is very obsolete however.
            for (recursive_directory_iterator end, dir(testDir);
                  dir != end; ++dir) {
                if (!is_directory(dir->status()))
                    runSCMTarget(dir->path().string().c_str());
            }
        }
        catch(std::string s) {
            std::cerr << "testSCMTargets:" << s;
            throw s;
        }
        catch(StandardException e) {
            std::cerr << "testSCMTargets:" << e.getMessage();
            throw e;
        }
        catch(PLNexception e)
        {
            std::cerr << "testSCMTargets:" << e.what();
            throw e;
        }
        catch(...)
        {
            std::cerr << "Unknown exception during SCM targets" << std::endl;
            throw;
        }
    }
    
    void DISABLEtestSCMTargetsFC() {
        bool tmp = TESTING_BACKWARD_CHAINING;
        
        TESTING_BACKWARD_CHAINING = false;
        testSCMTargets();
        TESTING_BACKWARD_CHAINING = tmp;
    }

    // A meta-level test that can run all of the tests multiple times;
    // necessary if you use a non-deterministic heuristic for the BIT
    // search.
    void testHeuristic() {
        if (testFitnessEvaluator == BEST)
        return;

        for (int t=0; t < TestRepeats; t++)
        {
            setupHeuristicTestRun();
        
            // run all of the relevant tests
            runPLNTestsOnce();

            INstatsV[t].push_back(allTestsInferenceNodes);

            if (testFitnessEvaluator != SOFTMAX)
            {
                //No need to play with temperatures or multiple test repeats.
                if (testFitnessEvaluator != RANDOM)
                    t = TestRepeats;
                tempi = temperaturesN;
            }

            INstatsVT.push_back(INstatsV);
        }
        exit(0);
    }
    
    // Tries to combine several RuleApps into a "macro rule", which takes one
    // argument but applies several different rules
    void DISABLEtestMacroRuleTest()
    {
        AtomSpaceWrapper *atw = GET_ASW;
        //typedef InversionRule RuleT1;
        //typedef DeductionRule RuleT2;

    //  DefaultVariableRuleProvider rp;
        InversionRule *invR = new InversionRule(atw, INHERITANCE_LINK);
        DeductionRule<DeductionSimpleFormula> *deduR = new DeductionRule<DeductionSimpleFormula>(atw, INHERITANCE_LINK);

        printf("v0\n");
        vtree v0(mva((pHandle)INHERITANCE_LINK,
                        mva(atw->addNode(CONCEPT_NODE, "Abu", SimpleTruthValue(0.05, 0.01))),
                        mva(atw->addNode(CONCEPT_NODE, "Osama",  SimpleTruthValue(0.01, 0.01)))
                        ));
        printf("v1\n");
        vtree v1(mva((pHandle)INHERITANCE_LINK,
                        mva(atw->addNode(CONCEPT_NODE, "Osama",  SimpleTruthValue(0.01, 0.01))),
                        mva(atw->addNode(CONCEPT_NODE, "AlQaeda",  SimpleTruthValue(0.1, 0.01)))
                        ));
        printf("v2\n");
        vtree v2(mva((pHandle)INHERITANCE_LINK,
                        mva(atw->addNode(CONCEPT_NODE, "AlQaeda",  SimpleTruthValue(0.1, 0.01))),
                        mva(atw->addNode(CONCEPT_NODE, "terrorist",  SimpleTruthValue(0.2, 0.01)))));

        printf("h0\n");
        pHandle h0 = atw->addAtom(v0, 
                                  SimpleTruthValue(0.40f, getCount(0.80f)));
        printf("h1\n");
        pHandle h1 = atw->addAtom(v1,
                                  SimpleTruthValue(0.60f, getCount(0.90f)));
        printf("h2\n");
        pHandle h2 = atw->addAtom(v2,
                                  SimpleTruthValue(0.98f, getCount(0.95f)));

        RuleApp* top    = new RuleApp(deduR);
        RuleApp* child1a= new RuleApp(deduR);

        child1a->Bind(0, new VtreeProviderWrapper(Vertex(h0)));
        child1a->Bind(1, new VtreeProviderWrapper(Vertex(h1)));
        child1a->compute();

        top->Bind(0, child1a);
        top->Bind(1, new VtreeProviderWrapper(Vertex(h2)));

        BoundVertex res1a = top->compute();
        const TruthValue& tvA = atw->getTV(_v2h(res1a.value));
        TS_ASSERT(tvA.getMean() > 0.01);
        TS_ASSERT(tvA.getConfidence() > 0.01);

        RuleApp* topb   = new RuleApp(deduR);
    //  RuleApp* child1b= vtree(Vertex(h0));
        RuleApp* child2b= new RuleApp(deduR);

        child2b->Bind(0, new VtreeProviderWrapper(Vertex(h1)));
        child2b->Bind(1, new VtreeProviderWrapper(Vertex(h2)));
        topb->Bind(0, new VtreeProviderWrapper(Vertex(h0)));
        topb->Bind(1, child2b);

        BoundVertex res1b = topb->compute();
        // Checks that they have the same pHandles, which is wrong
        //TS_ASSERT_EQUALS(res1a.value, res1b.value);

        const TruthValue& tvB = atw->getTV(_v2h(res1a.value));
        TS_ASSERT(isApproxEq(tvB.getMean(), tvA.getMean(), EPSILON_S));
        TS_ASSERT(isApproxEq(tvB.getConfidence(), tvA.getConfidence(),
                  EPSILON_C));

        RuleApp* top2 = new RuleApp(invR);
        top2->Bind(0, topb);
        RuleApp* top3 = new RuleApp(invR);
        top3->Bind(0, top2);

        const TruthValue& tv2 = atw->getTV(_v2h(top2->compute().value));
        TS_ASSERT(!isApproxEq(tvB.getMean(), tv2.getMean(), EPSILON_S));
    //  assert(!isApproxEq(tvB.getConfidence(), tv2.getConfidence(), EPSILON_C));

        const TruthValue& tv3 = atw->getTV(_v2h(top3->compute().value));
        // segfaults in this next line
        TS_ASSERT(isApproxEq(tvB.getMean(), tv3.getMean(), EPSILON_S));
        TS_ASSERT(isApproxEq(tvB.getConfidence(), tv3.getConfidence(),
                  EPSILON_C));


        vector<VtreeProvider*> args;
        args.push_back(new VtreeProviderWrapper(Vertex(h0)));
        args.push_back(new VtreeProviderWrapper(Vertex(h1)));
        args.push_back(new VtreeProviderWrapper(Vertex(h2)));

        RuleApp* topc   = new RuleApp(deduR);
        RuleApp* child2c= new RuleApp(deduR);

        topc->Bind(1, child2c);

        BoundVertex resC = topc->compute(args.begin(), args.end());

        TS_ASSERT(resC.value == res1b.value);
        const TruthValue& tvC = atw->getTV(_v2h(resC.value));
        TS_ASSERT(isApproxEq(tvB.getMean(), tvC.getMean(), EPSILON_S));
        TS_ASSERT(isApproxEq(tvB.getConfidence(), tvC.getConfidence(),
                  EPSILON_C));


        RuleApp* topd   = new RuleApp(deduR);
        RuleApp* child1d= new RuleApp(deduR);

        topd->Bind(0, child1d);

        BoundVertex resD = topd->compute(args.begin(), args.end());

        TS_ASSERT(resD.value == res1b.value);
        const TruthValue& tvD = atw->getTV(_v2h(resD.value));
        TS_ASSERT(isApproxEq(tvB.getMean(), tvD.getMean(), EPSILON_S));
        TS_ASSERT(isApproxEq(tvB.getConfidence(), tvD.getConfidence(),
                  EPSILON_C));
        printf("finish MacroRuleTest\n");
    }

    //! The failure tests do still work (but are disabled because they make
    //! PLNUTest fail!)
    void testTVChecksWork() {
        /// The test which is supposed to fail
        if(RUN_FAILURE_TESTS) {
            initAxiomSet(PLN_TEST_DIR"scm/bigdemo.scm");

            puts("\nShould fail. The test for whether TV checks work.\n");

            maketest(makemeta(mva((pHandle)INHERITANCE_LINK,
                            NewNode(CONCEPT_NODE, "AlQaeda"),
                            NewNode(CONCEPT_NODE, "terrorist")
                    )),
                    new SimpleTruthValue(0.95f, getCount(0.90f)),
                    new SimpleTruthValue(0.999f, getCount(0.999f)),
                    50,0);
        }
    }

    void testRandomTVsTooHigh() {
        if(RUN_FAILURE_TESTS) {
            initAxiomSet(PLN_TEST_DIR"scm/smalldemo.scm");

            puts("\nShould fail. The test for whether random TVs come out too high:\n");

            maketest(makemeta(mva((pHandle)EVALUATION_LINK,
                            NewNode(PREDICATE_NODE, "killed"),
                            mva((pHandle)LIST_LINK,
                                        NewNode(FW_VARIABLE_NODE, "$killeri"),
                                        NewNode(CONCEPT_NODE, "Osama")
                                    )
                    )),
                    new SimpleTruthValue(0.5f, getCount(0.5f)),
                    new SimpleTruthValue(0.51f, getCount(0.51f)),
                    10,0);
        }
    }

    void testSymmetricRelationFails() {
        if(RUN_FAILURE_TESTS) {
            puts("\nShould fail.");
            initAxiomSet(PLN_TEST_DIR"scm/smalldemo.scm");
            maketest(makemeta(mva((pHandle)EVALUATION_LINK,
                            NewNode(PREDICATE_NODE, "symmetricRelation"),
                            mva((pHandle)LIST_LINK,
                                        NewNode(CONCEPT_NODE, "Amir"),
                                        NewNode(CONCEPT_NODE, "Osama")
                                    )
                    )),
                    new SimpleTruthValue(0.0f, getCount(0.0f)),
                    new SimpleTruthValue(0.01f, getCount(0.01f)),
                    10,0);
        }
    }

    //! Involves friendOf being a symmetricRelation
    void testBasicSpawning()
    {
        for (int i = 0; i < 5; i++) {
            printf("\nBasic spawning test %d\n", i);
            /// Basic spawning test
            initAxiomSet(PLN_TEST_DIR"scm/smalldemo.scm");
            maketest(makemeta(mva((pHandle)EVALUATION_LINK,
                        NewNode(PREDICATE_NODE, "friendOf"),
                        mva((pHandle)LIST_LINK,
                                    NewNode(CONCEPT_NODE, "Britney"),
                                    NewNode(CONCEPT_NODE, "Amir")
                                ))),
                new SimpleTruthValue(0.78f, getCount(0.39f)),
                new SimpleTruthValue(1.001f, getCount(0.999f)),
                100,0);
        }
    }

    void DISABLEtestFingerPrint(vtree& v)
    {
        BoundVTree bvt(v);
        printf("Finger print: %lu\n", bvt.getFingerPrint());
    }
    
    void testUnifiesWithVariableChangeTo()
    {
        map<pHandle,pHandle> bindings;
        cout << "Testing unification" << endl;

        TS_ASSERT( unifiesWithVariableChangeTo(
                        GET_ASW,
                        mva((pHandle)AND_LINK,
                            NewNode(CONCEPT_NODE, "Osama"),
                            NewNode(CONCEPT_NODE, "terrorist")),
                        mva((pHandle)AND_LINK,
                            NewNode(CONCEPT_NODE, "Osama"),
                            NewNode(CONCEPT_NODE, "terrorist")),
                        bindings));

        TS_ASSERT(!unifiesWithVariableChangeTo(
                        GET_ASW,
                        mva((pHandle)AND_LINK,
                            NewNode(CONCEPT_NODE, "Osama"),
                            NewNode(CONCEPT_NODE, "terrorist")),
                        mva((pHandle)AND_LINK,
                            NewNode(CONCEPT_NODE, "Osama"),
                            NewNode(CONCEPT_NODE, "terrorist_DIFF")),
                        bindings));

        TS_ASSERT(!unifiesWithVariableChangeTo(
                        GET_ASW,
                        mva((pHandle)AND_LINK,
                            NewNode(CONCEPT_NODE, "Osama"),
                            NewNode(CONCEPT_NODE, "terrorist")),
                        mva((pHandle)AND_LINK,
                            NewNode(FW_VARIABLE_NODE, "Osama"),
                            NewNode(CONCEPT_NODE, "terrorist")),
                        bindings));

        TS_ASSERT( unifiesWithVariableChangeTo(
                        GET_ASW,
                        mva((pHandle)AND_LINK,
                            NewNode(FW_VARIABLE_NODE, "1"),
                            NewNode(CONCEPT_NODE, "terrorist")),
                        mva((pHandle)AND_LINK,
                            NewNode(FW_VARIABLE_NODE, "2"),
                            NewNode(CONCEPT_NODE, "terrorist")),
                        bindings));

        TS_ASSERT(!unifiesWithVariableChangeTo(
                        GET_ASW,
                        mva((pHandle)AND_LINK,
                            NewNode(FW_VARIABLE_NODE, "1"),
                            NewNode(CONCEPT_NODE, "terrorist")),
                        mva((pHandle)AND_LINK,
                            NewNode(FW_VARIABLE_NODE, "2"),
                            NewNode(CONCEPT_NODE, "terrorist_DIFF")),
                        bindings));
        TS_ASSERT(!unifiesWithVariableChangeTo(
                        GET_ASW,
                        mva((pHandle)AND_LINK,
                            NewNode(FW_VARIABLE_NODE, "1"),
                            NewNode(CONCEPT_NODE, "terrorist")),
                        mva((pHandle)AND_LINK,
                            NewNode(FW_VARIABLE_NODE, "2"),
                            NewNode(CONCEPT_NODE, "terrorist"),
                            NewNode(CONCEPT_NODE, "terrorist_DIFF")),
                        bindings));
    }

};

// this has basically been reduced to a repository of commented out tests
#if 0
void runPLNTestsOnce()
{
// These are some of the targets in TestTargets.h, but telling you the file you
// need too.
/*  /// Untested with current PLN implementation:

    maketest(makemeta(mva((Handle)EVALUATION_LINK,
                    NewNode(PREDICATE_NODE, "friendOf"),
                    mva((Handle)LIST_LINK,
                                NewNode(CONCEPT_NODE, "Amir"),
                                NewNode(CONCEPT_NODE, "Osama")
                            )
            )),
            new SimpleTruthValue(0.01f, getCount(0.01f)),
            new SimpleTruthValue(1.01f, getCount(1.01f)),
            "bigdemo.xml",
            10,0);

    maketest(makemeta(mva((Handle)EVALUATION_LINK,
                    NewNode(PREDICATE_NODE, "wasKilled"),
                    mva((Handle)LIST_LINK,
                                NewNode(CONCEPT_NODE, "Osama")
                            )
            )),
            new SimpleTruthValue(0.01f, getCount(0.01f)),
            new SimpleTruthValue(1.01f, getCount(1.01f)),
            "bigdemo.xml",
            10,0);
*/
/*      initAxiomSet("bigdemo.xml");
        maketest(makemeta(mva((Handle)EVALUATION_LINK,
                    NewNode(PREDICATE_NODE, "friendOf"),
                    mva((Handle)LIST_LINK,
                                NewNode(FW_VARIABLE_NODE, "$OsamaFriend"),
                                NewNode(CONCEPT_NODE, "Osama")
                            ))),
            new SimpleTruthValue(0.01f, getCount(0.01f)),
            new SimpleTruthValue(1.01f, getCount(1.01f)),
            10,0);*/
/*  maketest(makemeta(mva((Handle)INHERITANCE_LINK,
                    NewNode(CONCEPT_NODE, "Osama"),
                    NewNode(CONCEPT_NODE, "AlQaeda")
            )),
            new SimpleTruthValue(0.01f, getCount(0.01f)),
            new SimpleTruthValue(1.01f, getCount(1.01f)),
            "bigdemo.xml",
            10,0);
    maketest(makemeta(mva((Handle)EVALUATION_LINK,
                    NewNode(PREDICATE_NODE, "killed"),
                    mva((Handle)LIST_LINK,
                                NewNode(FW_VARIABLE_NODE, "$killeri"),
                                NewNode(CONCEPT_NODE, "Osama")
                            )
            )),
            new SimpleTruthValue(0.01f, getCount(0.01f)),
            new SimpleTruthValue(1.01f, getCount(1.01f)),
            "bigdemo.xml",
            10,0);
    maketest(makemeta(mva((Handle)EVALUATION_LINK,
                        NewNode(PREDICATE_NODE, "do"),
                        mva((Handle)LIST_LINK,
                            mva((Handle)EVALUATION_LINK,
                                NewNode(SCHEMA_NODE, "give"),
                                mva((Handle)LIST_LINK,
                                    NewNode(CONCEPT_NODE, "ball"),
                                    NewNode(CONCEPT_NODE, "teacher")
                                )
                            )                                       
                        )
            )),
            new SimpleTruthValue(0.01f, getCount(0.01f)),
            new SimpleTruthValue(1.01f, getCount(1.01f)),
            "fetchdemo4.xml",
            10,0);
    maketest(makemeta(mva((Handle)EVALUATION_LINK,
                    NewNode(PREDICATE_NODE, "+++")
            )),
            new SimpleTruthValue(0.01f, getCount(0.01f)),
            new SimpleTruthValue(1.01f, getCount(1.01f)),
            "fetchdemo4.xml",
            10,0);
    maketest(makemeta(mva((Handle)EVALUATION_LINK,
                        NewNode(PREDICATE_NODE, "near"),
                        mva((Handle)LIST_LINK,
                                NewNode(CONCEPT_NODE, "teacher")
                        )
                    )
            ),
            new SimpleTruthValue(0.01f, getCount(0.01f)),
            new SimpleTruthValue(1.01f, getCount(1.01f)),
            "fetchdemo4.xml",
            10,0);
    maketest(makemeta(mva((Handle)IMPLICATION_LINK,
                NewNode(FW_VARIABLE_NODE, "$1"),
                mva((Handle)EVALUATION_LINK,
                    NewNode(PREDICATE_NODE, "+++")
                )
            )),
            new SimpleTruthValue(0.01f, getCount(0.01f)),
            new SimpleTruthValue(1.01f, getCount(1.01f)),
            "fetchdemo4.xml",
            10,0);
*/
/*  maketest(makemeta(mva(
            )),
            new SimpleTruthValue(0.01f, getCount(0.01f)),
            new SimpleTruthValue(1.01f, getCount(1.01f)),
            "fetchdemo4.xml",
            10,0);
    maketest(makemeta(mva(
            )),
            new SimpleTruthValue(0.01f, getCount(0.01f)),
            new SimpleTruthValue(1.01f, getCount(1.01f)),
            "bigdemo.xml",
            10,0);
*/

    INstatsV.push_back(INstats);
}
#endif
